# Lab04 非线性方程求根

**古宜民 PB17000002**

**2019.4.6**

### 1. 计算结果

按要求编写Newton法和弦截法求根程序，输入目标函数$f(x)=2x^4+24x^3+61x^2-16x+1$、初值和误差限$10^{-10}$计算每步的迭代结果和误差。

由Mathematica计算得到的四个精确解为{{x -> 1/2 (-4 - 3 Sqrt[2])}, {x ->1/2 (-4 + 3 Sqrt[2])}, {x -> -4 - Sqrt[17]}, {x -> -4 + Sqrt[17]}}，在[0,1]内的解为1/2 (-4 + 3 Sqrt[2])~=0.121320343560

结果如下：

```
>> calcu
Newton
Init,	x0 0.000000000000e+00, f(x0) 1.000000000000e+00
Iter   1,	x0 6.250000000000e-02, f(x0) 2.441711425781e-01
Iter   2,	x0 9.267514482259e-02, f(x0) 6.035782170991e-02
Iter   3,	x0 1.075091602299e-01, f(x0) 1.499476015164e-02
Iter   4,	x0 1.148532337630e-01, f(x0) 3.724889874781e-03
Iter   5,	x0 1.184836815217e-01, f(x0) 9.162606433633e-04
Iter   6,	x0 1.202426067745e-01, f(x0) 2.157726880186e-04
Iter   7,	x0 1.210258178988e-01, f(x0) 4.284768185225e-05
Iter   8,	x0 1.212838327059e-01, f(x0) 4.653095935891e-06
Iter   9,	x0 1.213196266734e-01, f(x0) 8.956906283331e-08
Iter  10,	x0 1.213203432722e-01, f(x0) 3.590072683579e-11
 
Init,	x0 1.000000000000e+00, f(x0) 7.200000000000e+01
Iter   1,	x0 6.129032258065e-01, f(x0) 1.991614267569e+01
Iter   2,	x0 3.857131772105e-01, f(x0) 5.325335197644e+00
Iter   3,	x0 2.596036488719e-01, f(x0) 1.386360679278e+00
Iter   4,	x0 1.925129685567e-01, f(x0) 3.545098794691e-01
Iter   5,	x0 1.577981765912e-01, f(x0) 8.968654972282e-02
Iter   6,	x0 1.401281446851e-01, f(x0) 2.254753819569e-02
Iter   7,	x0 1.312211106524e-01, f(x0) 5.640836772056e-03
Iter   8,	x0 1.267683504527e-01, f(x0) 1.398662165777e-03
Iter   9,	x0 1.245798350719e-01, f(x0) 3.365432712847e-04
Iter  10,	x0 1.235651039653e-01, f(x0) 7.221204915153e-05
Iter  11,	x0 1.231837476806e-01, f(x0) 1.019051840478e-05
Iter  12,	x0 1.231087710564e-01, f(x0) 3.937825602263e-07
Iter  13,	x0 1.231056311436e-01, f(x0) 6.905834792903e-10
Iter  14,	x0 1.231056256177e-01, f(x0) 2.220446049250e-15
String Cut
Init,	x0 0.000000000000e+00, x1 1.000000000000e-01, f(x0) 1.000000000000e+00
Iter   1,	x0 1.000000000000e-01, x1 1.035411058190e-01, f(x0) 3.420000000000e-02
Iter   2,	x0 1.035411058190e-01, x1 1.120858281072e-01, f(x0) 2.417951833043e-02
Iter   3,	x0 1.120858281072e-01, x1 1.156346859438e-01, f(x0) 7.095473154011e-03
Iter   4,	x0 1.156346859438e-01, x1 1.181829468231e-01, f(x0) 2.965518222788e-03
Iter   5,	x0 1.181829468231e-01, x1 1.196409053300e-01, f(x0) 1.079222604559e-03
Iter   6,	x0 1.196409053300e-01, x1 1.205229933328e-01, f(x0) 4.068164063683e-04
Iter   7,	x0 1.205229933328e-01, x1 1.210063890599e-01, f(x0) 1.440173238525e-04
Iter   8,	x0 1.210063890599e-01, x1 1.212339783325e-01, f(x0) 4.610054781695e-05
Iter   9,	x0 1.212339783325e-01, x1 1.213079454418e-01, f(x0) 1.130775027647e-05
Iter  10,	x0 1.213079454418e-01, x1 1.213197755884e-01, f(x0) 1.559168087528e-06
Iter  11,	x0 1.213197755884e-01, x1 1.213203396462e-01, f(x0) 7.095743470575e-08
Iter  12,	x0 1.213203396462e-01, x1 1.213203435584e-01, f(x0) 4.887535931530e-10
 
Init,	x0 5.000000000000e-01, x1 1.000000000000e+00, f(x0) 1.137500000000e+01
Iter   1,	x0 1.000000000000e+00, x1 4.061855670103e-01, f(x0) 7.200000000000e+01
Iter   2,	x0 4.061855670103e-01, x1 3.499565652206e-01, f(x0) 6.228027101352e+00
Iter   3,	x0 3.499565652206e-01, x1 2.537988158195e-01, f(x0) 3.929954963899e+00
Iter   4,	x0 2.537988158195e-01, x1 2.079352730174e-01, f(x0) 1.269117150683e+00
Iter   5,	x0 2.079352730174e-01, x1 1.750469085586e-01, f(x0) 5.300085908306e-01
Iter   6,	x0 1.750469085586e-01, x1 1.552774667210e-01, f(x0) 1.989823493760e-01
Iter   7,	x0 1.552774667210e-01, x1 1.427044636031e-01, f(x0) 7.735363552613e-02
Iter   8,	x0 1.427044636031e-01, x1 1.349353271930e-01, f(x0) 2.954315328494e-02
Iter   9,	x0 1.349353271930e-01, x1 1.301078071492e-01, f(x0) 1.132206511795e-02
Iter  10,	x0 1.301078071492e-01, x1 1.271316211049e-01, f(x0) 4.318021695917e-03
Iter  11,	x0 1.271316211049e-01, x1 1.253088367125e-01, f(x0) 1.640106488913e-03
Iter  12,	x0 1.253088367125e-01, x1 1.242135266821e-01, f(x0) 6.156158190977e-04
Iter  13,	x0 1.242135266821e-01, x1 1.235849666421e-01, f(x0) 2.244667452042e-04
Iter  14,	x0 1.235849666421e-01, x1 1.232632020970e-01, f(x0) 7.600081203396e-05
Iter  15,	x0 1.232632020970e-01, x1 1.231368294160e-01, f(x0) 2.143188696302e-05
Iter  16,	x0 1.231368294160e-01, x1 1.231081180018e-01, f(x0) 3.967781373904e-06
Iter  17,	x0 1.231081180018e-01, x1 1.231056684007e-01, f(x0) 3.119115794536e-07
Iter  18,	x0 1.231056684007e-01, x1 1.231056256773e-01, f(x0) 5.346778686466e-09
>> 
```

其中， 第一列为迭代次数，第二（三）列为当前获得的x值，第三（四）列为当前目标函数的值。



### 2. 结果分析

#### 关于f(x)的性质

画f(x)的图像，可见本次求根的零点为f的二阶零点。而四次多项式f一共有三个零点。

![f](.\f.png)

作为对比，取`x0=-6`、`x0=-4`进行Newton迭代，发现仅仅6次、4次就收敛，从中可见对二阶零点求根时相对而言更加困难的。这与理论相符。

```
x0=-6时的迭代
Init,	x0 -1.000000000000e+01, f(x0) 2.261000000000e+03
Iter   1,	x0 -8.889489194499e+00, f(x0) 5.935283444831e+02
Iter   2,	x0 -8.313614017153e+00, f(x0) 1.136713789560e+02
Iter   3,	x0 -8.138933276581e+00, f(x0) 8.679509264594e+00
Iter   4,	x0 -8.123227680016e+00, f(x0) 6.641683765770e-02
Iter   5,	x0 -8.123105632953e+00, f(x0) 3.991461369424e-06
Iter   6,	x0 -8.123105625618e+00, f(x0) 2.415845301584e-12
```

#### 两种方法对比分析

从计算结果可见，在题中给出的初始迭代条件下，两种算法都正确得到了方程的根。Newton法用了10、14次迭代收敛，弦截法用了12、18次。可见弦截法收敛慢于Newton法。且到迭代后期弦截法中x1和x0接近，分母f(x1)-f(x0)很小，也导致了计算精度问题。总体而言，Newton法在本条件下好于弦截法。

但是，Newton法要求函数的导数可以表示，这对函数要求较为严格，而弦截法就没有这个要求。

**使用$M=\frac{\epsilon_{k+1}}{\epsilon_k^p}$近似计算每步迭代的收敛阶。**Newton法x0=-6处求单根，p=2时M大致不变：

```
>> NewtonRootWithDbg(ftest, -6, 1e-10, 1000, 0.121320343560)
Init,	x0 -6.000000000000e+00, f(x0) -2.990000000000e+02
Order: 9.457382e-02
Iter   1,	x0 -3.422413793103e+00, f(x0) 8.255661691790e+01
Order: 3.559672e-01
Iter   2,	x0 -4.348934442834e+00, f(x0) -3.434699234503e+01
Order: 2.127645e-01
Iter   3,	x0 -4.130391254491e+00, f(x0) -1.309963085669e+00
Order: 2.346986e-01
Iter   4,	x0 -4.121338396627e+00, f(x0) -2.601906803292e-03
Order: 2.357003e-01
Iter   5,	x0 -4.121320343632e+00, f(x0) -1.039973085426e-08
Order: 2.357023e-01
Iter   6,	x0 -4.121320343560e+00, f(x0) -2.557953848736e-13
```

而在x0=0处求二重根时，p=1.3时M大致不变：

```
Init,	x0 0.000000000000e+00, f(x0) 1.000000000000e+00
Order: 9.128803e-01
Iter   1,	x0 6.250000000000e-02, f(x0) 2.441711425781e-01
Order: 1.139373e+00
Iter   2,	x0 9.267514482259e-02, f(x0) 6.035782170991e-02
Order: 1.399792e+00
Iter   3,	x0 1.075091602299e-01, f(x0) 1.499476015164e-02
Order: 1.692038e+00
Iter   4,	x0 1.148532337630e-01, f(x0) 3.724889874781e-03
Order: 1.990143e+00
Iter   5,	x0 1.184836815217e-01, f(x0) 9.162606433633e-04
Order: 2.207307e+00
Iter   6,	x0 1.202426067745e-01, f(x0) 2.157726880186e-04
Order: 2.122544e+00
Iter   7,	x0 1.210258178988e-01, f(x0) 4.284768185225e-05
Order: 1.420895e+00
Iter   8,	x0 1.212838327059e-01, f(x0) 4.653095935891e-06
Order: 4.210192e-01
Iter   9,	x0 1.213196266734e-01, f(x0) 8.956906283331e-08
Order: 2.799129e-02
Iter  10,	x0 1.213203432722e-01, f(x0) 3.590072683579e-11
Order: 9.031648e-01
Iter  11,	x0 1.213203435596e-01, f(x0) 0.000000000000e+00
```

这里只是大致粗略估算一下收敛阶，并不准确，但确实说明了Newton法求重根时收敛阶更低。

#### 总结

Newton法和弦截法各有利弊，Newton法快速、精度高，但对函数和初始条件有较高要求；而弦截法虽然收敛速度慢，但对函数性质要求低，不要求函数导数显式表示。二者各有用武之地。

### 3. 程序算法

使用MATLAB编程计算，为了保证通用性，将两个求根算法单独的文件里作为函数，包装好接口（目标函数、初值、误差限、最大迭代次数），可供任意程序调用。函数中使用了MATLAB符号计算库用于求导以及函数计算。Newton法中，使用了MATLAB中的`syms x`定义了变量，`diff`求导，并使用`eval`操作函数句柄，这样导致了程序可移植性变差，如果语言不支持函数求导则无法使用。而性能不佳的eval的使用也可能导致程序效率下降。

函数为保持代码简洁，未对分母为0等特殊情况特殊处理。

为了避免不收敛无法求根导致死循环，使用了最大迭代参数，如果超过迭代次数则返回NaN，增强了函数的健壮性。

为了方便调试，并且不让调试输出影响正常使用，使用了一个全局变量debugflg，如果该变量被置为特定值，则输出调试信息（每次迭代的结果等），否则只返回求得的根。

两种求根方式的代码大致相同，就是具体的迭代步骤不同，也可以考虑将类似功能合并为一个函数并以参数的形式决定调用方法。

函数代码：

NewtonRoot.m

```matlab
function [root] = NewtonRoot(f, x0, eps, itermax)
%NEWTONROOT Use Newton method to get the root of functions
global debugflg
if debugflg == 2
    fprintf('Init,\tx0 %.12e, f(x0) %.12e\n', x0, f(x0));
end
itertimes = 0;
% use matlab diff to get derivative, if fderive is given NaN
% if fderive == NaN
% get the derive of f(x) the function handle, 
% a simple diff is not enough
syms x
fderive = eval(['@(x)' char(diff(f(x)))]);
% end
% fderive = diff(f);
while abs(f(x0)) >= eps && itertimes < itermax

    x0 = x0 - f(x0) / fderive(x0);
    itertimes = itertimes + 1;
    if debugflg == 2
        fprintf('Iter %3d,\tx0 %.12e, f(x0) %.12e\n', itertimes, x0, f(x0));
    end
end
if itertimes < itermax
    root = x0;
else
    root = NaN;
end
end
```

StringCutRoot.m

```matlab
function [root] = StringCutRoot(f, x0, x1, eps, itermax)
%NEWTONROOT Use Newton method to get the root of functions
global debugflg
if debugflg == 2
    fprintf('Init,\tx0 %.12e, x1 %.12e, f(x0) %.12e\n', x0, x1, f(x0));
end
itertimes = 0;
% use matlab diff to get derivative, if fderive is given NaN
% if fderive == NaN
% get the derive of f(x) the function handle, 
% a simple diff is not enough
% end
% fderive = diff(f);
while abs(f(x1)) >= eps && itertimes < itermax
    x0old = x0;
    x1old = x1;
    x1 = x1old - f(x1old) * (x1old - x0old) / (f(x1) - f(x0));
    x0 = x1old;
    itertimes = itertimes + 1;
    if debugflg == 2
        fprintf('Iter %3d,\tx0 %.12e, x1 %.12e, f(x0) %.12e\n', ...
            itertimes, x0, x1, f(x0));
    end
end
if itertimes < itermax
    root = x1;
else
    root = NaN;
end
end
```
