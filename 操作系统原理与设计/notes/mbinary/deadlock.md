---
title: 『现代操作系统』死锁
date: 2018-06-08 10:33:25
tags: [操作系统,读书笔记]
categories: 
        - 操作系统
keywords: 
description: "死锁的定义, 建模(资源分配图, 以及死锁的处理( 检测并恢复; 死锁避免; 死锁预防)"
---


<!-- TOC -->

- [死锁定义](#死锁定义)
- [死锁建模--资源分配图](#死锁建模--资源分配图)
- [处理死锁](#处理死锁)
    - [鸵鸟算法](#鸵鸟算法)
    - [检测并恢复](#检测并恢复)
        - [死锁检测](#死锁检测)
        - [死锁恢复](#死锁恢复)
            - [利用抢占](#利用抢占)
            - [利用回滚](#利用回滚)
            - [杀死进程](#杀死进程)
    - [死锁避免](#死锁避免)
        - [资源轨迹图](#资源轨迹图)
        - [安全区域与不安全区域](#安全区域与不安全区域)
        - [银行家算法](#银行家算法)
    - [死锁预防](#死锁预防)
        - [死锁条件](#死锁条件)
        - [破坏互斥条件](#破坏互斥条件)
        - [破坏占有和等待条件](#破坏占有和等待条件)
        - [破坏不可抢占条件](#破坏不可抢占条件)
        - [破坏环路等待条件](#破坏环路等待条件)

<!-- /TOC -->

类型: 资源死锁, 通信死锁 etc

根据 拥有资源的进程抢占而不产生副作用

* 可抢占资源 preemptable resource


* 不可抢占资源 non

 
使用资源的顺序: 请求  ->  使用 -> 释放

<a id="markdown-死锁定义" name="死锁定义"></a>
# 死锁定义

如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的时间,那么,该进程集合是死锁的

<a id="markdown-死锁建模--资源分配图" name="死锁建模--资源分配图"></a>
# 死锁建模--资源分配图

圆形表示进程, 方形表示资源,  进程 -> 资源 表示请求,   进程 <- 资源, 表示占有

![资源分配图](https://upload-images.jianshu.io/upload_images/7130568-b562b5cc4d2f9ee5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


<a id="markdown-处理死锁" name="处理死锁"></a>
# 处理死锁
<a id="markdown-鸵鸟算法" name="鸵鸟算法"></a>
## 鸵鸟算法
忽略该问题
<a id="markdown-检测并恢复" name="检测并恢复"></a>
## 检测并恢复
检测死锁并恢复
<a id="markdown-死锁检测" name="死锁检测"></a>
### 死锁检测
	
![数据结构](https://upload-images.jianshu.io/upload_images/7130568-e6173f74ab245c7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![死锁检测算法](https://upload-images.jianshu.io/upload_images/7130568-f59934872b5946f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

<a id="markdown-死锁恢复" name="死锁恢复"></a>
### 死锁恢复
<a id="markdown-利用抢占" name="利用抢占"></a>
#### 利用抢占
选择挂起某个进程, 取决于哪一个进程拥有比较容易收回的资源
<a id="markdown-利用回滚" name="利用回滚"></a>
#### 利用回滚
周期性地保存 `检查点(checkpoint)`, 检查点应包括存储映像,资源状态(资源分给了哪些进程). 由于检查点不覆盖, 逐渐累积可能会占大量储存
<a id="markdown-杀死进程" name="杀死进程"></a>
#### 杀死进程
可以杀死环类的进程, 如果不行继续,  也可以杀死环外的进程(以释放环类进程需要的资源),  杀死的进程应该满足: 重新运行不会带来副作用, 比如编译进程可以, 但是数据库更新进程不行
<a id="markdown-死锁避免" name="死锁避免"></a>
## 死锁避免
在分配资源时避免发生死锁
<a id="markdown-资源轨迹图" name="资源轨迹图"></a>
### 资源轨迹图

![资源轨迹图](https://upload-images.jianshu.io/upload_images/7130568-5230cc928d411915.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

<a id="markdown-安全区域与不安全区域" name="安全区域与不安全区域"></a>
### 安全区域与不安全区域
横坐标是A进程执行代码过程, 纵坐标是B进程执行代码的过程, 阴影部分需要使用相应资源.  在单cpu上, 虚线轨迹, 只能是向上或向右延伸.  阴影部分表明两个进程都使用了一个资源, 互斥规则决定不可能进入阴影区域. .  而在图中的虚线轨迹, 目前还有机会不形成死锁, 称为安全区域. 可以发现, 只要轨迹进入了I5,I6,I1,I2,围成的区域, 就一定会形成死锁, 这就是不安全区域

<a id="markdown-银行家算法" name="银行家算法"></a>
### 银行家算法
Dijkstra提出,  banker's algorithm
基本思路就是 每次满足一个进程的资源  请求前, 检测是否会造成死锁, 如果造成,就不满足其请求,否则满足.(死锁检测算法可以利用[上文](#死锁检测)中的)

![](https://upload-images.jianshu.io/upload_images/7130568-bb6a8bd61823f8f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


![银行家算法](https://upload-images.jianshu.io/upload_images/7130568-d08905186ef3dc01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

`缺点`: 很多进程在运行前是不知道其需要资源的最大值,而且进程数不断变化,原本的资源也可能突然间不可用(如磁带机可能会坏掉), 所以缺乏实用价值  , 极少有系统使用
<a id="markdown-死锁预防" name="死锁预防"></a>
## 死锁预防
<a id="markdown-死锁条件" name="死锁条件"></a>
### 死锁条件
- 互斥
- 占有和请求
- 不可抢占
- 环路等待
针对死锁条件,由于是必要条件, 所以破坏其中一个就可以预防死锁的发生.

<a id="markdown-破坏互斥条件" name="破坏互斥条件"></a>
### 破坏互斥条件
可以用虚拟技术使资源不被一个进程所独占, 如打印机的假脱机技术(spooling),
还有一个思路: 避免分配那些不是绝对必要的资源,尽量做到尽可能少的进程可以真正请求资源

<a id="markdown-破坏占有和等待条件" name="破坏占有和等待条件"></a>
### 破坏占有和等待条件
一种实现方法: 规定所有进程在开始执行前请求所需的全部资源
缺点和银行家算法一样, 很多进程直到运行时才知道所需多少资源.
另一种方案是当一个进程请求资源时,先释放其当前占有的所有资源

<a id="markdown-破坏不可抢占条件" name="破坏不可抢占条件"></a>
### 破坏不可抢占条件
比如打印机假脱机技术, 但是不是所有资源都可以类似的虚拟化, 比如数据库的记录或者操作系统中的表都必须被锁定

<a id="markdown-破坏环路等待条件" name="破坏环路等待条件"></a>
### 破坏环路等待条件
给资源编号, 进程只能按编号的顺序(升序)请求. 这样资源分配图不会出现环,.
![](https://upload-images.jianshu.io/upload_images/7130568-bb7eb107efa2d53a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

